<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Pixel Night Walk</title>
<style>
  html,body{height:100%;margin:0;background:#0a0a12;color:#ddd;font-family:system-ui,Arial}
  .wrap{display:grid;place-items:center;height:100vh}
  canvas{image-rendering:pixelated;background:#071025;border:6px solid #111;box-shadow:0 8px 30px rgba(0,0,0,.6)}
  .ui{position:fixed;left:12px;top:12px;background:rgba(0,0,0,.35);padding:8px;border-radius:8px;font-size:13px}
  .hint{opacity:.8}
</style>
</head>
<body>
<div class="wrap">
  <canvas id="screen" width="320" height="180"></canvas>
</div>
<div class="ui">
  <div><strong>Pixel Night Walk</strong></div>
  <div class="hint">WASD / arrows to move · Shift to run · P to toggle stars</div>
  <div style="margin-top:6px;font-size:12px">Tip: open devtools & resize canvas style to scale up for crisp pixels</div>
</div>
<script>
// ----- Simple single-file pixel game (drop into index.html on GitHub Pages) -----
// Controls: arrow keys or WASD to move. Shift to run. P toggles stars.
// To publish: create a repo named <yourusername>.github.io, add this file as index.html, push to GitHub.

const canvas = document.getElementById('screen');
const ctx = canvas.getContext('2d');
// Turn off smoothing for crisp pixel look
ctx.imageSmoothingEnabled = false;

const TILE = 16; // tile size in pixels (virtual)
const MAP_W = 20;
const MAP_H = 12;

// A simple tilemap: 0 grass, 1 path, 2 tree (solid), 3 water
const map = [
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,2,0,0,0,0,0,0,2,0,0,0,0,0,0,
  0,0,0,0,0,0,2,0,0,0,0,0,0,2,0,0,0,0,0,0,
  0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,
  0,0,0,0,1,3,3,3,3,3,3,3,3,1,0,0,0,0,0,0,
  0,0,0,0,1,3,3,3,3,3,3,3,3,1,0,0,0,0,0,0,
  0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,2,0,0,0,
  0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,
  0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
];

function tileAt(x,y){
  if(x<0||y<0||x>=MAP_W||y>=MAP_H) return 2;
  return map[y*MAP_W + x];
}

// Player (16x16) in tile units
const player = { x:5.5, y:3.5, w:0.9, h:1.2, dir:0, frame:0, flick:0 };
let keys = {};
let starsOn = true;

window.addEventListener('keydown', e=>{ keys[e.key.toLowerCase()]=true; if(e.key==='p' || e.key==='P'){ starsOn=!starsOn } });
window.addEventListener('keyup', e=>{ keys[e.key.toLowerCase()]=false });

// Simple starfield
const SCOUNT = 80;
const stars = Array.from({length:SCOUNT},()=>({x:Math.random()*MAP_W*TILE, y:Math.random()*MAP_H*TILE, r:Math.random()*1.2+0.4, t:Math.random()}));

function worldToScreen(wx,wy){
  // center camera on player
  const scale = 1; // canvas is small; you can scale canvas CSS
  const camX = player.x*TILE - canvas.width/2;
  const camY = player.y*TILE - canvas.height/2;
  return {x: Math.round(wx - camX), y: Math.round(wy - camY)};
}

function update(dt){
  // movement
  let speed = (keys['shift'] ? 3.5 : 2.2);
  let dx=0, dy=0;
  if(keys['arrowleft']||keys['a']) dx-=1;
  if(keys['arrowright']||keys['d']) dx+=1;
  if(keys['arrowup']||keys['w']) dy-=1;
  if(keys['arrowdown']||keys['s']) dy+=1;
  const len = Math.hypot(dx,dy) || 1;
  dx = dx/len * speed * dt;
  dy = dy/len * speed * dt;

  // Collision with tile types 2 (tree) and water(3) (water slows and blocks slightly)
  function canMove(nx, ny){
    // check 4 corners of player box
    const left = nx - player.w/2, right = nx + player.w/2, top = ny - player.h/2, bottom = ny + player.h/2;
    const corners = [ [left,top],[right,top],[left,bottom],[right,bottom] ];
    for(const [cx,cy] of corners){
      const tx = Math.floor(cx), ty = Math.floor(cy);
      const t = tileAt(tx,ty);
      if(t===2) return false; // solid
    }
    return true;
  }

  // attempt x then y for simpler collision
  let nx = player.x + dx*0.016 * 60 / TILE; // convert px to tile-space (approx)
  if(canMove(nx, player.y)) player.x = nx;
  let ny = player.y + dy*0.016 * 60 / TILE;
  if(canMove(player.x, ny)) player.y = ny;

  // animation
  if(Math.abs(dx)+Math.abs(dy) > 0.01){
    player.frame += dt*10;
    player.flick = Math.min(1, player.flick + dt*6);
  } else { player.frame = 0; player.flick = Math.max(0, player.flick - dt*6); }
}

function drawTile(tx, ty, sx, sy){
  // simple colored tiles
  if(tx===0){ // grass
    ctx.fillStyle = '#0b4028';
    ctx.fillRect(sx,sy,TILE,TILE);
    // small noise
    ctx.fillStyle = '#094227';
    if(((tx+ty)&1)===0) ctx.fillRect(sx+2, sy+2, 1,1);
  } else if(tx===1){ // path
    ctx.fillStyle = '#5a5347'; ctx.fillRect(sx,sy,TILE,TILE);
  } else if(tx===2){ // tree
    ctx.fillStyle = '#0b4028'; ctx.fillRect(sx,sy,TILE,TILE);
    // trunk
    ctx.fillStyle = '#4b2b18'; ctx.fillRect(sx+6, sy+8, 4,8);
    // leaves
    ctx.fillStyle = '#164b2f'; ctx.fillRect(sx+2, sy+1, 12,8);
  } else if(tx===3){ // water
    ctx.fillStyle = '#052a3b'; ctx.fillRect(sx,sy,TILE,TILE);
    ctx.fillStyle = 'rgba(255,255,255,0.03)'; ctx.fillRect(sx+2, sy+2, 4,1);
  }
}

function draw(){
  // clear
  ctx.fillStyle = '#071025'; ctx.fillRect(0,0,canvas.width,canvas.height);

  // camera origin
  const camX = player.x*TILE - canvas.width/2;
  const camY = player.y*TILE - canvas.height/2;

  // draw tiles
  const startX = Math.floor(camX / TILE) - 1;
  const startY = Math.floor(camY / TILE) - 1;
  const endX = startX + Math.ceil(canvas.width / TILE) + 3;
  const endY = startY + Math.ceil(canvas.height / TILE) + 3;

  for(let y=startY;y<endY;y++){
    for(let x=startX;x<endX;x++){
      const t = tileAt(x,y);
      const sx = Math.round(x*TILE - camX);
      const sy = Math.round(y*TILE - camY);
      drawTile(t,0,sx,sy);
    }
  }

  // draw stars (behind)
  if(starsOn){
    for(const s of stars){
      const scr = worldToScreen(s.x, s.y);
      // parallax tiny shift based on player
      const px = scr.x - (player.x*TILE)/6; const py = scr.y - (player.y*TILE)/6;
      ctx.globalAlpha = 0.9 * (0.6 + 0.4*Math.sin(perf.now()/600 + s.t*10));
      ctx.fillStyle = '#fff';
      ctx.fillRect(Math.floor(px), Math.floor(py), Math.max(1, Math.round(s.r)), Math.max(1, Math.round(s.r)));
    }
    ctx.globalAlpha = 1;
  }

  // draw player as small pixel sprite
  const px = Math.round(canvas.width/2 - (player.w*TILE)/2);
  const py = Math.round(canvas.height/2 - (player.h*TILE)/2 - 4);

  // body
  ctx.fillStyle = '#e7c07a';
  ctx.fillRect(px+4, py+2, 6, 10);
  // head
  ctx.fillStyle = '#f7e0b0'; ctx.fillRect(px+4, py-6, 6, 6);
  // clothes (jacket)
  ctx.fillStyle = '#254c6b'; ctx.fillRect(px+4, py+6, 6, 2);
  // small legs
  ctx.fillStyle = '#162635'; ctx.fillRect(px+4, py+8, 2, 4);
  ctx.fillRect(px+8, py+8, 2, 4);

  // simple flashlight / torch glow: radial cutout in overlay will show this light
  // Draw lighting overlay
  ctx.save();
  ctx.fillStyle = 'rgba(0,0,10,0.85)';
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // create circular light around player by cutting a hole
  const grad = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 8, canvas.width/2, canvas.height/2, 120);
  grad.addColorStop(0, 'rgba(255,255,230,0.95)');
  grad.addColorStop(0.4, 'rgba(255,255,230,0.35)');
  grad.addColorStop(1, 'rgba(0,0,0,0)');

  // use destination-out to cut soft hole
  ctx.globalCompositeOperation = 'destination-out';
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.arc(canvas.width/2, canvas.height/2, 110, 0, Math.PI*2);
  ctx.fill();
  ctx.restore();

  // moon (top-right)
  ctx.fillStyle = '#fef6d6'; ctx.beginPath(); ctx.arc(canvas.width-36,36,12,0,Math.PI*2); ctx.fill();
  ctx.fillStyle = 'rgba(255,255,255,0.04)'; ctx.beginPath(); ctx.arc(canvas.width-36,36,18,0,Math.PI*2); ctx.fill();

  // small UI marker for player center (optional)
  //ctx.fillStyle='rgba(255,255,255,0.2)'; ctx.fillRect(canvas.width/2-1, canvas.height/2-1,2,2);
}

let last = performance.now();
function loop(){
  const now = performance.now();
  const dt = (now - last)/1000; last = now;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}

// Resize canvas CSS for crisp zoom but keep internal resolution fixed
function autoscale(){
  const scale = Math.floor(Math.min(window.innerWidth / canvas.width, window.innerHeight / canvas.height));
  const s = Math.max(1, Math.min(6, scale));
  canvas.style.width = (canvas.width * s) + 'px';
  canvas.style.height = (canvas.height * s) + 'px';
}
window.addEventListener('resize', autoscale);
autoscale();
requestAnimationFrame(loop);
</script>
</body>
</html>
